# 구현 기능

- 상품 주문
- 주문 내역 조회
- 주문 취소

# 순서

- 주문 엔티티, 주문 상품 엔티티 개발
- 주문 레포지토리 개발
- 주문 서비스 개발
- 주문 검색 기능 개발
- 주문 기능 테스트

# 개발

- 생성 메서드
    - 엔티티를 생성시 필요한 파라미터를 받아서 생성해주는 메서드를 정적으로 선언한다.
    - 이 경우, 기본 생성자의 생성은 막아야 한다. → protected로 변경
        - lombok을 사용하면 반복 코드를 줄일 수 있음 → @NoArgsConstructor(access = Accesslevel.PROTECTED)
- CASCADE.ALL
    - 연관관계를 맺은(어노테이션을 추가한) 객체들 전부 persist해주기 때문에 최상위 객체만 persist해도 된다.
    - CASCADE의 범위는?
        - 라이프사이클이 동일하고 외부에서 참조할 수 없는 객체들이라면 사용해도 된다.
        - 반대의 경우는 사용하면 안되고 별도의 레포지토리를 생성해야한다.

# JPA의 장점

- 데이터베이스 sql을 직접 다루는 라이브러리(Mybatis, JDBC Template)는 객체의 데이터 변경시 외부에서 해당 쿼리를 직접 만들어서 올려야한다.(Transaction Script 추가 작업)
- Dirty Checking(변경내역 감지)를 통해 객체의 바뀐 데이터를 감지해서 update쿼리가 자동으로 날라감

# 도메인 모델 패턴

- 본인의 상태변경을 자기자신이 관리하도록 클래스 내부에 관련 비즈니스 로직을 위치시킨다.(자율적인 객체)
- 비즈니스 로직이 엔티티 클래스 내부에 존재
- 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할을 한다.

# Transaction Script 패턴

- 엔티티 클래스 내부에는 비즈니스 로직이 없고 대부분의 로직을 서비스 계층에 둬서 처리하는 전략

# 도메인 모델 패턴 vs Transaction Script 패턴

- 결국 개발을 트레이드 오프의 산물이기 때문에, 상황에 맞게 두 전략을 유동적으로 사용하는 것이 좋다
- 도메인 모델 패턴이 단위 테스트 작성시 유리함

---

# 주문 검색 기능 개발

- JPA에서 동적 쿼리를 어떻게 해결해야 할까?
    - jpql을 동적으로 만들기
        - 문자열로 변환해서 조건별로 문자열 붙이기(비추)
        - JPA Criteria(동적쿼리 생성 JPA 표준)(너무 어렵고 유지보수가 불가능에 가깝다)
        - Querydsl

# 심화

- 코드 메서드로 추출하기 단축키: Command + Option + M
- 데이터 파라미터로 빼기 단축키: Command + Option + P
- 변수로 추출하기 단축키: Command + Option + V
- 동적쿼리
