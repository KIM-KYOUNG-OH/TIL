# 새로운 할인 정책 개발

- 고정 금액 할인이 아니라 주문 금액당 할인하는 정률 할인으로 변경

# 문제점

- 역할과 구현을 분리했다
- 다형성을 활용했다
- OCP와 DIP 원칙을 준수했다(X)

# DIP 위반

![스크린샷 2021-12-24 오전 12 46 51](https://user-images.githubusercontent.com/66231761/147263126-f1d0966c-b11b-458c-8a2d-31726af1145b.png)

- DIP는 추상화에 의존해야한다는 원칙
- 얼핏보면 주문 서비스는 인터페이스에만 의존하는 것처럼 보이지만, 사실 주문 서비스는 추상 클래스(DiscountPolicy) 뿐만 아니라 구현 클래스(FixDiscountPolicy)에도 의존하고 있다.

# OCP 위반

![스크린샷 2021-12-24 오전 12 47 14](https://user-images.githubusercontent.com/66231761/147263174-68680128-bc55-4a06-abb3-28a7ac4e5949.png)

- OCP는 변경에 닫혀있고 확장에 열려있어야 한다는 원칙
- 기능을 확장하면서 클라이언트 코드에 영향을 주기 때문에 OCP 위반

# 해결법

- 누군가 클라이언트에 구현 객체를 대신 생성하고 주입해주어야 한다.

---

# 관심사의 분리

- 공연에 비유
- 책임을 분리하자
- AppConfig
    - 애플리케이션의 전체 동작 방식을 구성하기 위해 구현 객체를 생성하고 연결하는 책임을 가지는 별도의 설정 클래스를 만들자
    - AppConfig는 애플리케이션의 실제 동작에 필요한 구현 객체를 생성한다.
    - AppConfig는 생성한 객체 인스턴스의 참조를 생성자를 통해 주입해준다.
- DIP를 지키게 되었으므로 추상화에만 의존하기 때문에 어떤 구현 객체가 들어올지는 오직 외부에서 결정한다.
- 의존관계에 대한 고민은 외부에 맡기고 실행에만 집중하면 된다.(관심사의 분리)

---

# AppConfig 리팩터링

- AppConfig는 역할이 잘 드러나게 설계해야한다.
- 중복 제거
- 애플리케이션 전체 구성을 빠르게 파악

# 새로운 구조와 할인 정책 적용

- AppConfig의 등장으로 애플리케이션을 사용 영역과 구성 영역으로 분리됌
- 
![스크린샷 2021-12-24 오전 12 47 39](https://user-images.githubusercontent.com/66231761/147263232-4baf39bf-0e60-4444-b764-00e727b94138.png)

- 이제 할인 정책을 변경해도 구성 역역인 AppConfig만 변경되고, 클라이언트 코드와 사용 영역의 어떤 코드도 변경할 필요가 없다.
- OCP 만족
    - 클라이언트 코드를 변경할 필요없이 기능 확장
- DIP 만족
    - 추상화에 의존

# 좋은 객체 지향 설계의 5가지 원칙 적용

# SRP 단일 책임 원칙

- 한 클래스는 하나의 책임만 가져야 한다.
- 이전의 클래스는 직접 구현 객체를 생성하고 연결하고 실행하는 다양한 책임을 가지고 있음
- 구현 객체를 생성하고 연결하는 책임은 AppConfig가 담당
- 실항하는 책임은 클라이언트 객체가 담당
- 관심사를 분리함

# DIP 의존관계 역전 원칙

- 구체화가 아닌 추상화에 의존해야 한다. 의존성 주입은 이 원칙을 따르는 방법 중 하나다.(DI까지 더해야 비로소 DIP가 완성)
- 이전의 코드는 구현체에 의존하거나 추상화와 구현체에 동시에 의존하는 경우가 많음
- 클라이언트 코드는 추상화 인터페이스에만 의존하도록하고 AppConfig를 이용해서 의존관계를 주입하여 DIP 적용

# OCP

- 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다.
- 다형성을 사용하고 클라이언트가 DIP를 지킴
- 애플리케이션을 사용 영역과 구성 영역으로 나눔
- AppConfig 의존 관계를 변경해서 클라이언트 코드에 주입하므로 클라이언트 코드는 변경할 필요가 없음
- 즉, 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀 있다.

---

# <IoC, DI, Container>

# 제어의 역전 IoC(Inversion of Control)

- 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 구현 객체를 생성, 연결, 실행했다.
- AppConfig 등장 이후로 구현 객체는 자신의 로직을 실행하는 역할만 담당하고 프로그램의 제어 흐름은 AppConfig가 담당한다.
- 프로그램의 제어 흐름을 구현 객체가 직접 관리하는게 아니라 외부에서 관리하는 것을 제어의 역전이라고 한다.

# 프레임워크 vs 라이브러리

- 프레임워크가 내가 작성한 코드를 제어하고 대신 실행하면 프레임워크
- 내가 작성한 코드가 직접 제어의 흐름을 담당하면 라이브러리

# DI

- 다형성 + DIP 가 적용되어 실제 어떤 구현 객체가 사용될지 모른다.
- 의존관계는 정적인 클래스 의존 관계와 실행 시점에 결정되는 동적인 객체 의존 관계가 있다.
- 정적인 클래스 의존 관계만 봐선 추상화된 인터페이스에 어떤 구현체가 주입될지 애플리케이션이 실행되기 전까진 모른다.
- DI는 런타임에 외부에서 구현 객체를 생성하고 클라이언트에게 전달해서 실제 의존관계를 연결하는 것을 말한다.

# IoC 컨테이너, DI 컨테이너

- AppConfig처럼 외부에서 구현체의 생성과 의존관계 연결하는 것을 IoC 컨테이너, DI 컨테이너라고 한다.
- 최근엔 주로 DI 컨테이너라고 함

---

# Spring 적용 하기

- ApplicationContext를 스프링 컨테이너라고 함
- 기존에는 AppConfig를 직접 생성하고 DI 했지만, 이제부터 스프링 컨테이너를 사용
- @Configuration은 @Bean으로 표시된 메서드를 모두 호출해서 스프링 컨테이너에 등록함
- @Bean이 붙은 메서드명을 이름으로 등록됌
- 이제부터 스프링 컨테이너에서 applicationContext.getBean()으로 스프링 빈을 찾아야 함
- 기존에는 개발자가 직접 자바코드로 모든 것을 했다면, 이제부터 스프링 컨테이너를 통해서 스프링 빈을 등록하고 찾아서 사용하도록 변경됌
- 과연 스프링 컨테이너의 장점이 뭘까?

# 심화

- 애자일 소프트웨어 선언
- 테스트 코드 생성하는 단축키: command + shift + T
- 함수 추출(Extract Method) 단축키: command + option + M
