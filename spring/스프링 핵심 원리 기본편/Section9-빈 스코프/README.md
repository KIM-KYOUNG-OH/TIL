- 지금까지 스프링 빈이 기본적으로 싱글톤 스코프로 생성되기 때문에, 스프링 컨테이너의 시작과 함께 생성되어 스프링 컨테이너가 종료될 때까지 유지된다고 배웠다.
- 스코프는 빈이 존재할 수 있는 범위를 뜻한다.
- 스프링은 다양한 스코프를 지원한다.
    - 싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
    - 프로토타입: 스프링 컨테이너는 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프
    - 웹 관련 스코프
        - request: 웹 요청이 들어오고 나갈 때까지 유지되는 스코프
        - session: 웹 세션이 생성되고 종료될 때까지 유지되는 스코프
        - application: 웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프

---

# 프로토타입 스코프

- 싱글톤 스코프의 빈을 조회하면 항상 같은 인스턴스의 스프링 빈을 반환한다.
- 프로토타입 스코프의 빈을 조회하면 항상 새로운 인스턴스를 생성해서 반환한다.
    ![스크린샷 2022-01-05 오전 1 16 57](https://user-images.githubusercontent.com/66231761/148089695-067b451c-c5ef-4ff7-b97d-e7be9e2f704b.png)

- 핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고 의존관계 주입, 초기화까지만 처리한다는 것이다.
- @PreDestroy 같은 종료 메서드가 호출되지 않는다. → 직접 호출해줘야 동작

# 프로토타입 정리

- 스프링 컨테이너에 요청할 때마다 새로 생성된다.
- 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입, 초기화까지만 관여한다.
- 종료 메서드가 호출되지 않는다.
- 프로토타입 빈은 프로토타입 빈을 호출한 클라이언트가 관리해야 한다. 종료 메서드에 대한 호출도 클라이언트가 직접 해야한다.

# 프로토타입 스코프와 싱글톤 빈과 함께 사용시 문제점

- 빈 사용할 때마다 빈을 새로 생성해서 사용하길 원해서 프로토타입 빈을 사용하겠지만 싱글톤 빈과 프로토타입 빈을 같이 사용하면 프로토타입 빈이 싱글톤으로 관리되어 버린다.
    - 프로토타입 빈은 기술적으로 의존관계를 주입받을 때마다 새로 생성된다.
    ![스크린샷 2022-01-05 오전 1 17 40](https://user-images.githubusercontent.com/66231761/148089778-95423c52-55f5-4b93-a211-d705a693f142.png)

# 프로토타입 스코프 싱글톤 빈과 함께 사용시 Provider로 문제 해결

- 쉬운 방법은 프로토타입 빈을 사용할 때마다 스프링 컨테이너에 새로 요청하는 것이다.
- 다만, 스프링 컨테이너에 종속적이게 되고 단위 테스트도 어려워짐

# ObjectFactory, ObjectProvider

- 지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공하는 인터페이스
- 과거에는 ObjectFactory가 있었는데 편의 기능을 추가해서 ObjectProvider가 만들어짐

# JSR-330 Provider

- javax.inject.Provider라는 자바 표준을 사용하는 방법
- 별도의 라이브러리를 Gradle에 추가해줘야 함 `implementation 'javax.inject:javax.inject:1'`
- provider.get()으로 새로운 프로토타입 빈이 생성되는 것을 확인할 수 있다.
- 딱 필요한 DL 정도의 기능만 제공한다.
- 매우 단순하다

# 정리

- 프로토타입 빈을 언제 사용할까?
    - 매번 사용할 때마다 주입이 완료된 새로운 객체가 필요하면 사용하면 된다.
    - 싱글톤 빈으로 대부분 문제가 해결됨
    - 굉장히 드물다
- JPA는 표준과 기능이 겹칠 때 자바 표준을 보통 사용
- Spring은 표준과 기능이 겹칠 때 Spring 진영을 사용
    - Spring이 곧 표준이 되어 버렸다...

---

# 웹 스코프

- 웹 스코프는 웹 환경에서만 동작한다.
- HTTP 요청 하나가 들어오고 나갈 때까지 유지되는 스코프
- 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성

    ![스크린샷 2022-01-05 오전 1 18 12](https://user-images.githubusercontent.com/66231761/148089850-d7c17382-ac16-45ff-8e13-590fdefe0759.png)
    
- 웹 스코프의 종류
    - request
    - session
    - application
    - websocket
- spring-boot-stater-web 라이브러리를 추가하면 스프링 부트는 내장 톰켓 서버를 활용해서 웹 서버와 스프링을 함께 실행시킨다.

# request 스코프 예제 개발

- [UUID][requestURL]{message} 포멧으로 사용자의 요청 로그가 남도록 request 스코프를 활용해서 기능을 개발해보자
- `request 스코프 빈이라 HTTP 요청이 오기 전까진 스프링 컨테이너에 생성된 빈이 없다`
- ObjectProvider.getObject()를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있다.
- 사용자 요청이 많아도 같은 HTTP 요청이면 같은 스프링 빈을 반환해준다

# 스코프와 프록시

- `@Scope(value = "request", proxyMode = ScopedProxyMode.*TARGET_CLASS*)`
- proxyMode를 추가하면, CGLIB 라이브러리로 가짜 프록시 클래스를 만들어서 주입함
- 가짜 프록시 객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있다
- 핵심은 진짜 객체 조회를 꼭 필요한 시점까지 지연 처리 한다는 점이다.
- 단지 어노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다.
    - 다형성과 DI 컨테이너의 가장 큰 장점
- 꼭 필요한 곳만 사용해야지, 무분별하게 사용하면 유지보수가 어려워짐

# 심화

- DL(Dependency Lookup) 의존관계 조회(탐색)
- 스프링 인터셉터
