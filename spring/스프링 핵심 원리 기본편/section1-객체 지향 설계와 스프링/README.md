# 스프링 탄생

- EJB(Enterprise JavaBeans)의 문제점
    - 복잡하고 어려운데 느림
- EJB 엔티티빈 → Hibernate → JPA(자바표준)
    - Hibernate는 JPA의 구현체중에서 점유율이 가장 높음

# 스프링의 역사

- 2002년 Rod Johnson 책 출간(예시 코드가 오픈소스로 발전)
- Spring Framework 4.0부터 자바8 지원
- 스프링 설정을 쉽게하기 위한 스프링 부트 2.0 출시

# 스프링이란?

- 스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드 등

# 스프링 프레임워크

- 핵심: 스프링 DI 컨테이너, AOP, 이벤트

# 스프링 부트

- 스프링을 편리하게 사용할 수 있도록 지원
- Tomcat 내장(빌드 간략화)
- starter 종속성 제공
- 외부 라이브러리의 버전간 충돌을 알아서 테스트해서 제공
- 간결한 설정

# 스프링의 핵심

- 자바 기반 프레임워크
- 객체 지향 애플리케이션을 개발할 수 있게 도와주는 도구

---

# 객체 지향 프로그래밍

- 객체들간 협력을 맺는 것
- 객체는 메시지를 통해 데이터를 주고받음
- 유연하고 변경이 용이한 프로그램 설계

# 다형성

- 역할과 구현을 분리
- 객체는 추상화된 역할에만 의존하므로 구현 대상에 변경이 발생해도 클라이언트에게 영향이 없다
- 클라이언트는 객체의 구현부의 내부 정보를 알 필요가 없음
- 역할: interface, 구현: 구현 클래스

# 다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 런타임에 유연하게 변경할 수 있다.
- 클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경할 수 있다.

# 역할과 구현 분리의 한계

- 역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두 큰 변경이 발생
- 인터페이스를 안정적으로 잘 설계하는 것이 중요

---

# SOLID 원칙

# SRP(single responsibility principle) 단일 책임 원칙

- 한 클래스는 하나의 책임만 가져야 한다.
- 변경의 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것

# OCP(Open/Closed principle) 개방-폐쇄 원칙

- 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다.
- 다형성
- 인터페이스의 구현 클래스를 추가하는 것(확장)

# OCP에 대한 오해

- 단순히 인터페이스를 구현하는 객체를 생성하는 것이 OCP를 지키는 것이 아니다.
- 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.(OCP 위반)
- 구현 객체 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요

# LSP(Liskov substitution principle) 리스코프 치환 원칙

- 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 쉽게 말하면, 다형성에서 하위 구현 클래스는 인터페이스 규약을 지켜야 한다는 것
- 인터페이스의 구현체를 믿고 사용하려면 이 원칙이 필요함.

# ISP(Interface segregation principle) 인터페이스 분리 원칙

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리
- 인터페이스가 최소화되면 인터페이스가 명확해지고 대체 가능성이 높아짐

# DIP(Dependency inversion principle) 의존관계 역전 원칙

- 구체화가 아닌 추상화에 의존해야함
- 클라이언트 코드가 구현 클래스가 아닌 인터페이스(역할)에 의존해야 한다.
- 구현체에 의존하면 변경이 어려워짐(클라이언트 코드를 바꿔야함)

# 정리

- 객체 지향의 핵심은 다형성
- 다형성만으로는 OCP, DIP를 지킬 수 없다.

---

# 객체 지향 설계와 스프링

- 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원
    - DI: 의존관계, 의존성 주입
    - DI 컨테이너 제공
- **클라이언트 코드의 변경없이 기능 확장 가능**

# 정리

- 설계 단계에서 역할과 구현을 분리하자
- 인터페이스를 부여하면 구현에 구애받지 않음

# 실무 고민

- 인터페이스를 도입하면 추상화라는 비용이 발생함
- 기능을 확장할 가능성이 없다면 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 인터페이스를 도입하는 것도 좋은 방법이다.
