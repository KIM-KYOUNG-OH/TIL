# 2장 객체지향 프로그래밍

# 인터페이스를 두는 것의 장점

- 인터페이스를 사용하는 프로그래머 입장에서 알아야할 정보를 최소화할 수 있다.
- 인터페이스를 사용하는 프로그래머에 대한 사이드 이팩트를 걱정하지 않고 제공자가 마음대로 내부 구현 코드를 수정할 수 있다.

# 협력

- 객체간 상호작용
- 메시지를 통해 정보를 전달
- 메시지와 메서드를 구분하는 다형성 개념 사용

# Template Method 패턴

- 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 추가적인 처리를 자식클래스에 위임하는 방식
- 상속 + 다형성

# 오버라이딩 vs 오버로딩

# 의존성이란?

어떤 클래스 내부에 다른 클래스에 접근할 수 있는 경로를 가지거나 다른 클래스의 메서드를 호출한 경우 의존성을 가진다고 함

# 컴파일 타임 의존성 vs 런타임 의존성

- 컴파일 타임엔 인터페이스에 의존하고 런타임엔 인스턴스를 생성하는 시점에 인자로 세부 구현체를 전달한다.
- 컴파일 타임 의존성과 런타임 의존성이 다르면 다를수록 코드는 더 유연해진다.
- 다만 코드를 이해하기 어려워짐

# 트레이드오프

- 컴파일 타임 의존성과 런타임 의존성이 다를수록 더 유연하고 확장에 유리함
- 반면 코드를 이해하기 여럽고 디버깅이 어려워짐
- 유연성 ↔  가독성

# 상속

- 기존 클래스의 모든 필드와 메서드를 그대로 물려줌
- 상속은 인터페이스 상속을 위해서만 사용해야함
- 구현을 상속하는 방식은 오히려 강결합을 유발해 변경에 취약한 코드를 야기함

# 다형성

동일한 메시지를 수신했을 때 객체 타입에 따라 다르게 응답할 수 있는 능력

# 추상화

- 추상화된 상위 클래스만 공개하여 도메인 흐름을 설명 가능
- 추상화된 클래스만 수정하지 않는다면 구현 클래스 추가 + 오버라이딩으로 쉽게 기능을 추가할 수 있다

# 코드 재사용

- 상속보단 합성
- 상속은 캡슐화를 위반하여 유연성을 해침

# 합성

- 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함하는 방법
- 느슨한 결합으로 캡슐화를 해치지 않고 코드 재사용 가능
