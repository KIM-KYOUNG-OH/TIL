# Chapter 04 CPU 스케줄링  
## CPU 스케줄러란?  
프로세스의 생성부터 종료까지 모든 상태 변화를 조정하는 관리자이다.  
## 스케줄링 목적  
- 모든 프로세스가 공평하게 작업하도록 자원을 골고루 배분하여 시스템 전체가 안정적으로 작동되게 하기 위함  
- 프로세스 수가 급증해도 성능에 갑작스런 변화가 없도록 함  
- 틀정 프로세스가 시스템 자원을 독점하는 것을 막음  
- 우선순위에 따라 CPU를 할당하여 전체 시스템 성능을 높임  
## 규모에 따른 CPU 스케줄링  
- 고수준 스케줄링  
  : 시스템내 전체 작업수 조절  
- 중간 수준 스케줄링  
  : 시스템 과부화시 활성화된 프로세스를 보류 상태로 보냄  
- 저수준 스케줄링  
  : 일반적인 프로세스 상태 변화 컨트롤  
## 선점형 스케줄링 vs 비선점형 스케줄링  
### 1. 선점형 스케줄링  
  - 어떤 프로세스가 실행중이어도 OS가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
  - 문맥교환이 자주 일어나, 오버헤드가 많다  
  - 시분할 방식  
### 2. 비선점형 스케줄링  
  - 어떤 프로세스가 실행중이면 OS가 CPU를 강제로 빼앗을 수 없는 스케줄링 방식  
  - 기다리는 프로세스가 많아서 처리율이 떨어짐
  - 일괄 작업 방식  
## 프로세스 우선 순위  
커널 프로세스 우선 순위 > 일반 프로세스 우선 순위  
## CPU 집중 프로세스 vs 입출력 집중 프로세스  
- 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 시스템 효율 향상  
- 입출력 집중 프로세스는 CPU를 잠깐 쓰고 대기 상태로 전환되므로 그 시간 동안 다른 프로세스가 CPU를 사용할 수 있다.  
### 1. CPU 집중 프로세스  
  : CPU를 많이 사용하는 프로세스  
### 2. 입출력 집중 프로세스  
  : 데이터 입출력을 많이 사용하는 프로세스  
## 전면 프로세스 vs 후면 프로세스  
### 1. 전면 프로세스  
  : GUI 운영체제 환경에서 화면 맨앞에 놓인 프로세스  
### 2. 후면 프로세스  
  : 사용자와 상호작용이 없는 프로세스  
|우선순위 높음|우선순위 낮음|
|:---:|:---:|
|커널 프로세스|일반 프로세스|
|전면 프로세스|후면 프로세스|
|대화형 프로세스|일괄처리 프로세스|
|입출력 집중 프로세스|CPU 집중 프로세스|  
-- -- --  
## 다중 큐  
- 프로세스의 우선순위는 PCB에 표시됨  
- CPU 스케줄러가 매번 PCB를 탐색하는 것은 번거롭기 때문에 다중 큐에 우선순위에 따라 PCB를 관리한다.  
## 준비상태 다중 큐  
- 프로세스는 우선순위별로 큐의 tail에 삽입되고 dispatch시 맨 앞의 프로세스를 꺼내어 PCB를 할당한다.  
### 프로세스의 우선순위를 배정하는 방식  
#### 1. 고정 우선순위 방식  
  - 운영체제가 한번 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식
  - 시스템 변화에 대응이 어려워지고 작업 효율 감소  
#### 2. 변동 우선순위 방식  
  - 운영체제가 한번 우선순위를 부여한 이후에도 우선순위를 변경할 수 있는 방식  
  - 구현이 어렵지만 시스템 효율 상승  
## 대기상태 다중 큐  
- 입출력 장치별로 큐에 모여있다.  
- 대부분 순서대로 처리되지만 일부는 나중에 들어온 PCB가 먼저 나가기도 함  
## 준비 큐 vs 대기 큐  
- 준비 큐: 한번에 하나의 프로세스를 꺼내어 CPU할당  
- 대기 큐: 한번에 여러 개의 PCB를 꺼내어 준비 상태로 옮김(입출력이 동시에 끝날 경우 여러 개 인터럽트가 한꺼번에 처리됨을 의미)  
-- -- --  
## 스케줄링 알고리즘  
- 비선점형 알고리즘: FCFS, SJF, HRN  
- 선점형 알고리즘: RR, SRT, 다단계 큐, 다단계 피드백 큐  
## CPU 스케줄링 알고리즘 효율성 평가 기준
- 대기시간  
- 응답시간  
- 실행시간  
- 반환시간  
## FCFS 스케줄링  
- First Come First Served  
- 준비 큐에 도착한 순서대로 CPU 할당  
- 처리 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들은 하염없이 기다려야하는 Convoy Effect가 발생  
## SJF 스케줄링  
- Shortest Job First  
- 준비 큐에 실행 시간이 짧은 프로세스부터 CPU 할당  
- Convoy Effect를 완화할 수 있지만 아래의 이유로 안씀  
  - 사용자의 상호작용이 빈번하게 발생하므로 OS가 프로세스의 종료시간을 정확히 예측하기 어렵다  
  - 공평성 위배로 인해 작업 시간이 긴 프로세스가 계속 연기되는 아사 현상이 발생  
## HRN 스케줄링  
- Hightest Response Ratio Next  
- 아사 현상을 완화하기 위해 우선순위를 정할 때 대기시간을 고려한 방식  
- 우선순위 = (대기시간 + CPU 사용시간) / CPU 사용시간  
- 공평성 위배로 인해 안씀  
## 라운드 로빈 스케줄링(RR, Round Robin)  
- 타임 슬라이스 동안 작업하고 작업 완료하지 못하면 다시 준비 큐의 맨 뒤로 가서 차례를 기다리는 선점형 방식  
- FCFS의 평균 대기 시간과 같다면 라운드 로빈이 더 비효율적이다.  
- 문맥교환이 많아서 시스템 성능에 영향을 줌  
### 1) 타임 슬라이스가 큰 경우
  - FCFS와 같다  
### 2) 타임 슬라이스각 작은 경우  
  - 동시에 실행되는 것처럼 느껴지지만 문맥 교환에 많은 시간을 낭비하게 된다.  
- 대략 타임 슬라이스를 10~200 밀리초 사이로 조절해야함  
## SRT 우선 스케줄링  
- Shortest Remaining Time  
- SJF와 RR을 혼합한 방식
- CPU를 할당할 때 남은 작업 시간이 가장 작은 프로세스를 선택하여 타임 슬라이스 동안 작업한다.  
- SJF와 같은 이유로 잘 안씀  
## 다단계 큐 스케줄링  
- 우선순위별로 다단계로 나누어 RR 방식으로 큐를 사용하는 방법  
- 고정형 우선순위를 사용하며 상단의 큐의 모든 프로세스의 작업이 완료되야 다음 큐를 시작함  
- 우선순위가 낮은 프로세스는 작업이 연기되는 문제가 있다.  
## 다단계 피드백 큐 스케줄링  
- 우선순위가 낮은 프로세스에 불리한 다단계 큐의 단점을 보완한 방식  
- CPU를 사용하고난 프로세스를 우선순위가 한 단계 낮아짐(단, 커널 프로세스는 제외)  
- 다단계 큐와 다르게 타임 슬라이스 크기가 우선순위에 따라 다르다(우선순위가 낮을 수록 타임 슬라이스가 커짐)  
- 우선순위가 가장 낮은 프로세스는 타임 슬라이스가 무한이므로 FCFS와 같다  
-- -- --  
## 인터럽트 처리  
- 동기적인 인터럽트(Synchronous Interrupt)  
  : 실행중인 명령어로 인해 발생하는 인터럽트  
- 비동기적인 인터럽트(Asynchronous Interrupt)  
  : 실행중인 명령어와 무관하게 발생하는 인터럽트  
IRQ: 인터럽트 고유 번호  
## 인터럽트 벡터  
: 인터럽트의 집합으로 여러개 인터럽트를 동시에 묶어서 처리할 때 사용  
## 이터럽트 헨들러  
: 인터럽트 벡터의 각 인터럽트 발생시 어떤 일을 처리할 것인가 함수가 미리 정의된 것  
## 이중모드  
- 운영체제가 자원을 보호하기 위해 사용하는 기법  
- 사용자 프로세스가 커널의 기능을 수행하려면 시스템 자원에 직접 접근하는게 아니라 시스템 호출을 통해서 커널 프로세스를 실행시키고 사용자 프로세스는 대기상태로 전환한다. 이렇게 두 모드를 전환하여 일을 처리하는 것을 이중모드라고 한다.  
- API를 통한 시스템 호출은 프로세스가 정상 실행되지만 인터럽트에 의한 커널 모드 진입은 프로세스를 강제 종료시킴  
